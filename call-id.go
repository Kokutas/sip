package sip

import (
	"fmt"
	"regexp"
	"strings"
)

// https://www.rfc-editor.org/rfc/rfc3261.html#section-8.1.1.4
//
// 8.1.1.4 Call-ID
//
// The Call-ID header field acts as a unique identifier to group
// together a series of messages.  It MUST be the same for all requests
// and responses sent by either UA in a dialog.  It SHOULD be the same
// in each registration from a UA.

// In a new request created by a UAC outside of any dialog, the Call-ID
// header field MUST be selected by the UAC as a globally unique
// identifier over space and time unless overridden by method-specific
// behavior.  All SIP UAs must have a means to guarantee that the Call-
// ID header fields they produce will not be inadvertently generated by
// any other UA.  Note that when requests are retried after certain
// failure responses that solicit an amendment to a request (for
// example, a challenge for authentication), these retried requests are
// not considered new requests, and therefore do not need new Call-ID
// header fields; see Section 8.1.3.5.

// Use of cryptographically random identifiers (RFC 1750 [12]) in the
// generation of Call-IDs is RECOMMENDED.  Implementations MAY use the
// form "localid@host".  Call-IDs are case-sensitive and are simply
// compared byte-by-byte.

// 	Using cryptographically random identifiers provides some
// 	protection against session hijacking and reduces the likelihood of
// 	unintentional Call-ID collisions.

// No provisioning or human interface is required for the selection of
// the Call-ID header field value for a request.

// For further information on the Call-ID header field, see Section
// 20.8.

// Example:

// 	Call-ID: f81d4fae-7dec-11d0-a765-00a0c91e6bf6@foo.bar.com
//
// https://www.rfc-editor.org/rfc/rfc3261#section-20.8
//
// 20.8 Call-ID
//
// The Call-ID header field uniquely identifies a particular invitation
// or all registrations of a particular client.  A single multimedia
// conference can give rise to several calls with different Call-IDs,
// for example, if a user invites a single individual several times to
// the same (long-running) conference.  Call-IDs are case-sensitive and
// are simply compared byte-by-byte.

// The compact form of the Call-ID header field is i.

// Examples:

// 	Call-ID: f81d4fae-7dec-11d0-a765-00a0c91e6bf6@biloxi.com
// 	i:f81d4fae-7dec-11d0-a765-00a0c91e6bf6@192.0.2.4
//
// https://www.rfc-editor.org/rfc/rfc3261#section-25.1
//
// Call-ID  =  ( "Call-ID" / "i" ) HCOLON callid
// callid   =  word [ "@" word ]

// Call-ID: All registrations from a UAC SHOULD use the same Call-ID
//            header field value for registrations sent to a particular
//            registrar.

//            If the same client were to use different Call-ID values, a
//            registrar could not detect whether a delayed REGISTER request
//            might have arrived out of order.
type CallID struct {
	field   string // "Call-ID" / "i"
	localId string
	host    string
	isOrder bool        // Determine whether the analysis is the result of the analysis and whether it is sorted during the analysis
	order   chan string // It is convenient to record the order of the original parameter fields when parsing
	source  string      // source string
}

func (i *CallID) SetField(field string) {
	if regexp.MustCompile(`^(?i)(call-id|i)$`).MatchString(field) {
		i.field = field
	} else {
		i.field = "Call-ID"
	}
}
func (i *CallID) GetField() string {
	return i.field
}
func (i *CallID) SetLocalId(localId string) {
	i.localId = localId
}
func (i *CallID) GetLocalId() string {
	return i.localId
}
func (i *CallID) SetHost(host string) {
	i.host = host
}
func (i *CallID) GetHost() string {
	return i.host
}

// source string
func (i *CallID) GetSource() string {
	return i.source
}
func NewCallID(localId string, host string) *CallID {
	return &CallID{
		field:   "Call-ID",
		localId: localId,
		host:    host,
		isOrder: false,
		order:   make(chan string, 1024),
	}
}
func (i *CallID) Raw() string {
	result := ""
	if i.isOrder {
		for data := range i.order {
			result += data
		}
		i.isOrder = false
		result += "\r\n"
		return result
	}
	if len(strings.TrimSpace(i.field)) == 0 {
		i.field = "Call-ID"
	}
	result += fmt.Sprintf("%s:", i.field)
	if len(strings.TrimSpace(i.localId)) > 0 {
		result += fmt.Sprintf(" %s", i.localId)
	}
	if len(strings.TrimSpace(i.host)) > 0 {
		if len(result) > 0 {
			result += fmt.Sprintf("@%s", i.host)
		} else {
			result += i.host
		}
	}
	result += "\r\n"
	return result
}
func (i *CallID) Parse(raw string) {
	raw = regexp.MustCompile(`\r`).ReplaceAllString(raw, "")
	raw = regexp.MustCompile(`\n`).ReplaceAllString(raw, "")
	raw = stringTrimPrefixAndTrimSuffix(raw, " ")
	if len(strings.TrimSpace(raw)) == 0 {
		return
	}
	// field regexp
	fieldRegexp := regexp.MustCompile(`(?i)(call-id|i)( )*:`)
	if !fieldRegexp.MatchString(raw) {
		return
	}
	i.source = raw
	// call-id order
	i.callidOrder(raw)
	field := fieldRegexp.FindString(raw)
	field = regexp.MustCompile(`:`).ReplaceAllString(field, "")
	field = stringTrimPrefixAndTrimSuffix(field, " ")
	i.field = field
	raw = fieldRegexp.ReplaceAllString(raw, "")
	raw = stringTrimPrefixAndTrimSuffix(raw, " ")
	// host regexp
	hostRegexp := regexp.MustCompile(`@.*`)
	if hostRegexp.MatchString(raw) {
		host := hostRegexp.FindString(raw)
		raw = strings.TrimSuffix(raw, host)
		host = regexp.MustCompile(`@`).ReplaceAllString(host, "")
		host = stringTrimPrefixAndTrimSuffix(host, " ")
		i.host = host
	}
	raw = stringTrimPrefixAndTrimSuffix(raw, " ")
	if len(strings.TrimSpace(raw)) > 0 {
		i.localId = raw
	}
}
func (i *CallID) callidOrder(raw string) {
	if i.order == nil {
		i.order = make(chan string, 1024)
	}
	i.isOrder = true
	defer close(i.order)
	i.order <- raw
}
