package header

import (
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"regexp"
	"sip"
	"sip/util"
	"strings"
)

//The Call-ID header field acts as a unique identifier to group
//together a series of messages.  It MUST be the same for all requests
//and responses sent by either UA in a dialog.  It SHOULD be the same
//in each registration from a UA.
//
//In a new request created by a UAC outside of any dialog, the Call-ID
//header field MUST be selected by the UAC as a globally unique
//identifier over space and time unless overridden by method-specific
//behavior.  All SIP UAs must have a means to guarantee that the Call-
//ID header fields they produce will not be inadvertently generated by
//any other UA.  Note that when requests are retried after certain
//failure responses that solicit an amendment to a request (for
//example, a challenge for authentication), these retried requests are
//not considered new requests, and therefore do not need new Call-ID
//header fields; see Section 8.1.3.5.
//
//Use of cryptographically random identifiers (RFC 1750 [12]) in the
//generation of Call-IDs is RECOMMENDED.  Implementations MAY use the
//form "localid@host".  Call-IDs are case-sensitive and are simply
//compared byte-by-byte.
//
//Using cryptographically random identifiers provides some
//protection against session hijacking and reduces the likelihood of
//unintentional Call-ID collisions.
//
//No provisioning or human interface is required for the selection of
//the Call-ID header field value for a request.
//
//For further information on the Call-ID header field, see Section
//20.8.
//
//Example:
//
//Call-ID: f81d4fae-7dec-11d0-a765-00a0c91e6bf6@foo.bar.com
//
//Call-ID  =  ( "Call-ID" / "i" ) HCOLON callid
//callid   =  word [ "@" word ]

type CallID struct {
	Field     string `json:"field"`
	CallId    string `json:"call-id"`
	*sip.Host `json:"host,omitempty"`
}

func CreateCallID() sip.Sip {
	return &CallID{}
}
func NewCallID(callId string, host *sip.Host) *CallID {
	return &CallID{
		Field:  "Call-ID",
		CallId: callId,
		Host:   host,
	}
}

func (c *CallID) Raw() string {
	result := ""
	if reflect.DeepEqual(nil, c) {
		return result
	}
	result += fmt.Sprintf("%v:", c.Field)
	if len(strings.TrimSpace(c.CallId)) > 0 {
		result += fmt.Sprintf(" %v", c.CallId)
		if c.Host != nil {
			result += fmt.Sprintf("@%v", c.Host.Raw())
		}
	}
	result += "\r\n"
	return result
}
func (c *CallID) JsonString() string {
	result := ""
	if reflect.DeepEqual(nil, c) {
		return result
	}
	data, err := json.Marshal(c)
	if err != nil {
		return result
	}
	result = fmt.Sprintf("%s", data)
	return result
}
func (c *CallID) Parser(raw string) error {
	if c == nil {
		return errors.New("callid caller is not allowed to be nil")
	}
	if len(strings.TrimSpace(raw)) == 0 {
		return errors.New("raw parameter is not allowed to be empty")
	}
	raw = util.TrimPrefixAndSuffix(raw, " ")
	raw = regexp.MustCompile(`\r`).ReplaceAllString(raw, "")
	raw = regexp.MustCompile(`\n`).ReplaceAllString(raw, "")

	// filed regexp
	fieldRegexp := regexp.MustCompile(`(?i)(call-id).*?:`)
	if fieldRegexp.MatchString(raw) {
		field := fieldRegexp.FindString(raw)
		c.Field = regexp.MustCompile(`:`).ReplaceAllString(field, "")
		raw = strings.ReplaceAll(raw, field, "")
		raw = strings.TrimSuffix(raw, " ")
		raw = strings.TrimPrefix(raw, " ")
		raw = util.TrimPrefixAndSuffix(raw, " ")
	}
	// host regext
	hostRegexp := regexp.MustCompile(`@.*`)
	if hostRegexp.MatchString(raw) {
		host := regexp.MustCompile(`@`).ReplaceAllLiteralString(hostRegexp.FindString(raw), "")
		host = util.TrimPrefixAndSuffix(host, " ")
		c.Host = sip.CreateHost().(*sip.Host)
		if err := c.Host.Parser(host); err != nil {
			return err
		}
		raw = hostRegexp.ReplaceAllLiteralString(raw, "")
		raw = util.TrimPrefixAndSuffix(raw, " ")
	}
	if len(strings.TrimSpace(raw)) > 0 {
		c.CallId = raw
	}
	return nil
}
func (c *CallID) Validator() error {
	if c == nil {
		return errors.New("callid caller is not allowed to be nil")
	}
	if len(strings.TrimSpace(c.Field)) == 0 {
		return errors.New("field is not allowed to be empty")
	}
	if !regexp.MustCompile(`(?i)(call-id)`).Match([]byte(c.Field)) {
		return errors.New("field is not match")
	}
	if c.Host != nil {
		return c.Host.Validator()
	}
	return nil
}
