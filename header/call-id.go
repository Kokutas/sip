package header

import (
	"errors"
	"fmt"
	"regexp"
	"github.com/kokutas/sip"
	"github.com/kokutas/sip/util"
	"strings"
)

//The Call-ID header field acts as a unique identifier to group
//together a series of messages.  It MUST be the same for all requests
//and responses sent by either UA in a dialog.  It SHOULD be the same
//in each registration from a UA.
//
//In a new request created by a UAC outside of any dialog, the Call-ID
//header field MUST be selected by the UAC as a globally unique
//identifier over space and time unless overridden by method-specific
//behavior.  All SIP UAs must have a means to guarantee that the Call-
//ID header fields they produce will not be inadvertently generated by
//any other UA.  Note that when requests are retried after certain
//failure responses that solicit an amendment to a request (for
//example, a challenge for authentication), these retried requests are
//not considered new requests, and therefore do not need new Call-ID
//header fields; see Section 8.1.3.5.
//
//Use of cryptographically random identifiers (RFC 1750 [12]) in the
//generation of Call-IDs is RECOMMENDED.  Implementations MAY use the
//form "localid@host".  Call-IDs are case-sensitive and are simply
//compared byte-by-byte.
//
//Using cryptographically random identifiers provides some
//protection against session hijacking and reduces the likelihood of
//unintentional Call-ID collisions.
//
//No provisioning or human interface is required for the selection of
//the Call-ID header field value for a request.
//
//For further information on the Call-ID header field, see Section
//20.8.
//
//Example:
//
//Call-ID: f81d4fae-7dec-11d0-a765-00a0c91e6bf6@foo.bar.com
//
//Call-ID  =  ( "Call-ID" / "i" ) HCOLON callid
//callid   =  word [ "@" word ]

type CallID struct {
	field  string
	callId string
	*sip.Host
}

func (c *CallID) Field() string {
	return c.field
}

func (c *CallID) SetField(field string) {
	c.field = field
}

func (c *CallID) CallId() string {
	return c.callId
}

func (c *CallID) SetCallId(callId string) {
	c.callId = callId
}

func NewCallID(callId string, host *sip.Host) *CallID {
	return &CallID{field: "Call-ID", callId: callId, Host: host}
}

func (c *CallID) Raw() (string,error) {
	result := ""
	if err:=c.Validator();err!=nil {
		return result,err
	}
	if len(strings.TrimSpace(c.field))==0{
		c.field = "Call-ID"
	}
	result += fmt.Sprintf("%v:", c.field)
	if len(strings.TrimSpace(c.callId)) > 0 {
		result += fmt.Sprintf(" %v", c.callId)
		if c.Host != nil {
			res,err:=c.Host.Raw()
			if err!=nil{
				return "",err
			}
			result += fmt.Sprintf("@%v", res)
		}
	}
	result += "\r\n"
	return result,nil
}
func (c *CallID) String() string {
	result := ""
	if len(strings.TrimSpace(c.field))>0{
		result+=fmt.Sprintf("field: %s,",c.field)
	}
	if len(strings.TrimSpace(c.callId))>0{
		result +=fmt.Sprintf("call-id: %s,",c.callId)
	}
	if c.Host!=nil{
		result +=fmt.Sprintf("%s,",c.Host.String())
	}
	result = strings.TrimSuffix(result,",")
	return result
}
func (c *CallID) Parser(raw string) error {
	if c == nil {
		return errors.New("callid caller is not allowed to be nil")
	}
	if len(strings.TrimSpace(raw)) == 0 {
		return errors.New("raw parameter is not allowed to be empty")
	}
	raw = regexp.MustCompile(`\r`).ReplaceAllString(raw, "")
	raw = regexp.MustCompile(`\n`).ReplaceAllString(raw, "")
	raw = util.TrimPrefixAndSuffix(raw, " ")
	// filed regexp
	fieldRegexp := regexp.MustCompile(`(?i)(call-id).*?:`)
	if fieldRegexp.MatchString(raw) {
		field := fieldRegexp.FindString(raw)
		c.field = regexp.MustCompile(`:`).ReplaceAllString(field, "")
		raw = strings.ReplaceAll(raw, field, "")
		raw = strings.TrimSuffix(raw, " ")
		raw = strings.TrimPrefix(raw, " ")
		raw = util.TrimPrefixAndSuffix(raw, " ")
	}
	// host regext
	hostRegexp := regexp.MustCompile(`@.*`)
	if hostRegexp.MatchString(raw) {
		host := regexp.MustCompile(`@`).ReplaceAllLiteralString(hostRegexp.FindString(raw), "")
		host = util.TrimPrefixAndSuffix(host, " ")
		c.Host = new(sip.Host)
		if err := c.Host.Parser(host); err != nil {
			return err
		}
		raw = hostRegexp.ReplaceAllLiteralString(raw, "")
		raw = util.TrimPrefixAndSuffix(raw, " ")
	}
	if len(strings.TrimSpace(raw)) > 0 {
		c.callId = raw
	}
	return nil
}
func (c *CallID) Validator() error {
	if c == nil {
		return errors.New("callID caller is not allowed to be nil")
	}
	if len(strings.TrimSpace(c.field)) == 0 {
		return errors.New("field is not allowed to be empty")
	}
	if !regexp.MustCompile(`(?i)(call-id)`).Match([]byte(c.field)) {
		return errors.New("field is not match")
	}
	if c.Host != nil {
		return c.Host.Validator()
	}
	return nil
}
