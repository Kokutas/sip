package header

import (
	"errors"
	"fmt"
	"reflect"
	"regexp"
	"github.com/kokutas/sip"
	"github.com/kokutas/sip/util"
	"strings"
)

//The From header field indicates the logical identity of the initiator
//of the request, possibly the user's address-of-record.  Like the To
//header field, it contains a URI and optionally a display name.  It is
//used by SIP elements to determine which processing rules to apply to
//a request (for example, automatic call rejection).  As such, it is
//very important that the From URI not contain IP addresses or the FQDN
//of the host on which the UA is running, since these are not logical
//names.
//
//The From header field allows for a display name.  A UAC SHOULD use
//the display name "Anonymous", along with a syntactically correct, but
//otherwise meaningless URI (like sip:thisis@anonymous.invalid), if the
//identity of the client is to remain hidden.
//
//Usually, the value that populates the From header field in requests
//generated by a particular UA is pre-provisioned by the user or by the
//administrators of the user's local domain.  If a particular UA is
//used by multiple users, it might have switchable profiles that
//include a URI corresponding to the identity of the profiled user.
//Recipients of requests can authenticate the originator of a request
//in order to ascertain that they are who their From header field
//claims they are (see Section 22 for more on authentication).
//
//The From field MUST contain a new "tag" parameter, chosen by the UAC.
//See Section 19.3 for details on choosing a tag.
//
//For further information on the From header field, see Section 20.20.
//Examples:
//
//From: "Bob" <sips:bob@biloxi.com> ;tag=a48s
//From: sip:+12125551212@phone2net.com;tag=887s
//From: Anonymous <sip:c8oqz84zk7z@privacy.org>;tag=hyh8

// From        =  ( "From" / "f" ) HCOLON from-spec
// from-spec   =  ( name-addr / addr-spec )
//                *( SEMI from-param )
// from-param  =  tag-param / generic-param
// tag-param   =  "tag" EQUAL token
type From struct {
	field       string
	displayName string
	addr        *sip.SipUri
	tag         string
}

func (from *From) Field() string {
	return from.field
}

func (from *From) SetField(field string) {
	from.field = field
}

func (from *From) DisplayName() string {
	return from.displayName
}

func (from *From) SetDisplayName(displayName string) {
	from.displayName = displayName
}

func (from *From) Addr() *sip.SipUri {
	return from.addr
}

func (from *From) SetAddr(addr *sip.SipUri) {
	from.addr = addr
}

func (from *From) Tag() string {
	return from.tag
}

func (from *From) SetTag(tag string) {
	from.tag = tag
}

func NewFrom(displayName string, addr *sip.SipUri, tag string) *From {
	return &From{
		field:       "From",
		displayName: displayName,
		addr:        addr,
		tag:         tag,
	}
}
func (from *From) Raw() (string, error) {
	result := ""
	if err := from.Validator(); err != nil {
		return result, err
	}
	//The optional "display-name" is meant to be rendered by a human user
	//   interface.  A system SHOULD use the display name "Anonymous" if the
	//   identity of the client is to remain hidden.  Even if the "display-
	//   name" is empty, the "name-addr" form MUST be used if the "addr-spec"
	//   contains a comma, question mark, or semicolon.  Syntax issues are
	//   discussed in Section 7.3.1.
	result += fmt.Sprintf("%s:", strings.Title(from.field))
	if len(strings.TrimSpace(from.displayName)) > 0 {
		if strings.Contains(from.displayName, "\"") {
			result += fmt.Sprintf(" %s", from.displayName)
		} else {
			result += fmt.Sprintf(" \"%s\"", from.displayName)
		}
		//	if !reflect.DeepEqual(nil, from.addr) {
		//		res,err:=from.addr.Raw()
		//		if err!=nil{
		//			return "",err
		//		}
		//		result += fmt.Sprintf(" %v", res)
		//} else {
		//	if !reflect.DeepEqual(nil, from.addr) {
		//		res,err:=from.addr.Raw()
		//		if err!=nil{
		//			return "",err
		//		}
		//		result += fmt.Sprintf(" <%v>", res)
		//	}
	}
	// If the name-addr / addr-spec need to be commented as follows, release the comment in the display name
	if !reflect.DeepEqual(nil, from.addr) {
		res, err := from.addr.Raw()
		if err != nil {
			return "", err
		}
		result += fmt.Sprintf(" <%v>", res)
	}
	if len(strings.TrimSpace(from.tag)) > 0 {
		result += fmt.Sprintf(";tag=%v", from.tag)
	}
	result += "\r\n"
	return result, nil
}
func (from *From) String() string {
	result := ""
	if len(strings.TrimSpace(from.field)) > 0 {
		result += fmt.Sprintf("field: %s,", from.field)
	}
	if len(strings.TrimSpace(from.displayName)) > 0 {
		result += fmt.Sprintf("display-name: %s,", from.displayName)
	}
	if from.addr != nil {
		result += fmt.Sprintf("%s,", from.addr.String())
	}
	if len(strings.TrimSpace(from.tag)) > 0 {
		result += fmt.Sprintf("tag: %s,", from.tag)
	}
	result = strings.TrimSuffix(result, ",")
	return result
}
func (from *From) Parser(raw string) error {
	if from == nil {
		return errors.New("from caller is not allowed to be nil")
	}
	if len(strings.TrimSpace(raw)) == 0 {
		return errors.New("raw parameter is not allowed to be empty")
	}
	raw = util.TrimPrefixAndSuffix(raw, " ")
	raw = regexp.MustCompile(`\r`).ReplaceAllString(raw, "")
	raw = regexp.MustCompile(`\n`).ReplaceAllString(raw, "")

	// filed regexp
	fieldRegexp := regexp.MustCompile(`(?i)(from).*?:`)
	if fieldRegexp.MatchString(raw) {
		field := fieldRegexp.FindString(raw)
		from.field = regexp.MustCompile(`:`).ReplaceAllString(field, "")
		raw = strings.ReplaceAll(raw, field, "")
		raw = strings.TrimSuffix(raw, " ")
		raw = strings.TrimPrefix(raw, " ")
	}
	// schemas regexp
	schemasRegexpStr := `(?i)(`
	for _, v := range sip.Schemas {
		schemasRegexpStr += v + "|"
	}
	schemasRegexpStr = strings.TrimSuffix(schemasRegexpStr, "|")
	schemasRegexpStr += ")"
	// display name regexp
	displayNameRegexp := regexp.MustCompile(`.*?` + schemasRegexpStr)
	if displayNameRegexp.MatchString(raw) {
		displayNames := displayNameRegexp.FindString(raw)
		displayNames = regexp.MustCompile(schemasRegexpStr).ReplaceAllString(displayNames, "")
		displayNames = regexp.MustCompile(`<`).ReplaceAllString(displayNames, "")
		displayNames = regexp.MustCompile(`:`).ReplaceAllString(displayNames, "")
		raw = regexp.MustCompile(`.*`+displayNames).ReplaceAllString(raw, "")
		from.displayName = util.TrimPrefixAndSuffix(displayNames, " ")
		raw = util.TrimPrefixAndSuffix(raw, " ")
	}
	// tag
	tagRegexp := regexp.MustCompile(`;(?i)tag=.*`)
	if tagRegexp.MatchString(raw) {
		tag := tagRegexp.FindString(raw)
		raw = tagRegexp.ReplaceAllString(raw, "")
		from.tag = regexp.MustCompile(`;(?i)tag=`).ReplaceAllString(tag, "")
	}
	// addr regexp
	addrRegexp := regexp.MustCompile(schemasRegexpStr + `.*`)
	if addrRegexp.MatchString(raw) {
		addr := addrRegexp.FindString(raw)
		addr = util.TrimPrefixAndSuffix(addr, ";")
		addr = regexp.MustCompile(`<`).ReplaceAllString(addr, "")
		addr = regexp.MustCompile(`>.*`).ReplaceAllString(addr, "")
		addr = util.TrimPrefixAndSuffix(addr, ";")
		addr = util.TrimPrefixAndSuffix(addr, " ")
		from.addr = new(sip.SipUri)
		if err := from.addr.Parser(addr); err != nil {
			return err
		}
	}

	return nil
}
func (from *From) Validator() error {
	if from == nil {
		return errors.New("from caller is not allowed to be nil")
	}
	if len(strings.TrimSpace(from.field)) == 0 {
		return errors.New("field is not allowed to be empty")
	}
	if !regexp.MustCompile(`(?i)(from)`).Match([]byte(from.field)) {
		return errors.New("field is not match")
	}
	return from.addr.Validator()
}
