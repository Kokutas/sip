package sip

import (
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"sync"
)

// https://www.rfc-editor.org/rfc/rfc3261.html#section-8.1.1.3
//
// 8.1.1.3 From
// The From header field indicates the logical identity of the initiator
// of the request, possibly the user's address-of-record.  Like the To
// header field, it contains a URI and optionally a display name.  It is
// used by SIP elements to determine which processing rules to apply to
// a request (for example, automatic call rejection).  As such, it is
// very important that the From URI not contain IP addresses or the FQDN
// of the host on which the UA is running, since these are not logical
// names.

// The From header field allows for a display name.  A UAC SHOULD use
// the display name "Anonymous", along with a syntactically correct, but
// otherwise meaningless URI (like sip:thisis@anonymous.invalid), if the
// identity of the client is to remain hidden.

// Usually, the value that populates the From header field in requests
// generated by a particular UA is pre-provisioned by the user or by the
// administrators of the user's local domain.  If a particular UA is
// used by multiple users, it might have switchable profiles that
// include a URI corresponding to the identity of the profiled user.
// Recipients of requests can authenticate the originator of a request
// in order to ascertain that they are who their From header field
// claims they are (see Section 22 for more on authentication).

// The From field MUST contain a new "tag" parameter, chosen by the UAC.
// See Section 19.3 for details on choosing a tag.

// For further information on the From header field, see Section 20.20.
// Examples:

//    From: "Bob" <sips:bob@biloxi.com> ;tag=a48s
//    From: sip:+12125551212@phone2net.com;tag=887s
//    From: Anonymous <sip:c8oqz84zk7z@privacy.org>;tag=hyh8

// https://www.rfc-editor.org/rfc/rfc3261.html#section-20.20
//
// 20.20 From
// The From header field indicates the initiator of the request.  This
// may be different from the initiator of the dialog.  Requests sent by
// the callee to the caller use the callee's address in the From header
// field.

// The optional "display-name" is meant to be rendered by a human user
// interface.  A system SHOULD use the display name "Anonymous" if the
// identity of the client is to remain hidden.  Even if the "display-
// name" is empty, the "name-addr" form MUST be used if the "addr-spec"
// contains a comma, question mark, or semicolon.  Syntax issues are
// discussed in Section 7.3.1.

// Two From header fields are equivalent if their URIs match, and their
// parameters match. Extension parameters in one header field, not
// present in the other are ignored for the purposes of comparison. This
// means that the display name and presence or absence of angle brackets
// do not affect matching.

// See Section 20.10 for the rules for parsing a display name, URI and
// URI parameters, and header field parameters.

// The compact form of the From header field is f.

// Examples:

//    From: "A. G. Bell" <sip:agb@bell-telephone.com> ;tag=a48s
//    From: sip:+12125551212@server.phone2net.com;tag=887s
//    f: Anonymous <sip:c8oqz84zk7z@privacy.org>;tag=hyh8

// https://www.rfc-editor.org/rfc/rfc3261.html#section-25.1
//
// From        =  ( "From" / "f" ) HCOLON from-spec
// from-spec   =  ( name-addr / addr-spec )
// 				  *( SEMI from-param )
// from-param  =  tag-param / generic-param
// tag-param   =  "tag" EQUAL token

type From struct {
	field     string      //"From" / "f"
	name      string      // display-name
	spec      string      // named spec of URI,recommend set be uri spec <uri>,example: <sip:xxx>/"sip:xxx"/sip:xxx
	schema    string      // sip,sips,tel etc.
	user      string      // user part
	host      string      // host part
	port      uint16      // port part
	tag       string      // tag
	parameter sync.Map    // parameter-param
	isOrder   bool        // Determine whether the analysis is the result of the analysis and whether it is sorted during the analysis
	order     chan string // It is convenient to record the order of the original parameter fields when parsing
	source    string      // source string
}

func (f *From) SetField(field string) {
	if regexp.MustCompile(`^(?i)(from|f)$`).MatchString(field) {
		f.field = strings.Title(field)
	} else {
		f.field = "From"
	}
}
func (f *From) GetField() string {
	return f.field
}
func (f *From) SetName(name string) {
	f.name = name
}
func (f *From) GetName() string {
	return f.name
}
func (f *From) SetSpec(spec string) {
	f.spec = spec
}
func (f *From) GetSpec() string {
	return f.spec
}
func (f *From) SetSchema(schema string) {
	f.schema = schema
}
func (f *From) GetSchema() string {
	return f.schema
}
func (f *From) SetUser(user string) {
	f.user = user
}
func (f *From) GetUser() string {
	return f.user
}
func (f *From) SetHost(host string) {
	f.host = host
}
func (f *From) GetHost() string {
	return f.host
}
func (f *From) SetPort(port uint16) {
	f.port = port
}
func (f *From) GetPort() uint16 {
	return f.port
}
func (f *From) SetTag(tag string) {
	f.tag = tag
}
func (f *From) GetTag() string {
	return f.tag
}
func (f *From) SetParameter(parameter sync.Map) {
	f.parameter = parameter
}
func (f *From) GetParameter() sync.Map {
	return f.parameter
}
func (f *From) GetSource() string {
	return f.source
}

func NewFrom(name, spec, schema, user, host string, port uint16, tag string, parameter sync.Map) *From {
	return &From{
		name:      name,
		spec:      spec,
		schema:    schema,
		user:      user,
		host:      host,
		port:      port,
		tag:       tag,
		parameter: parameter,
		isOrder:   false,
	}
}

func (f *From) Raw() (result strings.Builder) {
	if len(strings.TrimSpace(f.field)) > 0 {
		result.WriteString(fmt.Sprintf("%s:", f.field))
	} else {
		result.WriteString(fmt.Sprintf("%s:", strings.Title("From")))
	}
	if len(strings.TrimSpace(f.name)) > 0 {
		if strings.Contains(f.name, "\"") {
			result.WriteString(fmt.Sprintf(" %s", f.name))
		} else {
			result.WriteString(fmt.Sprintf(" \"%s\"", f.name))
		}
	}
	uri := ""
	if len(strings.TrimSpace(f.schema)) > 0 {
		uri += fmt.Sprintf("%s:", strings.ToLower(f.schema))
	}
	if len(strings.TrimSpace(f.user)) > 0 {
		uri += f.user
	}
	if len(strings.TrimSpace(f.host)) > 0 {
		uri += fmt.Sprintf("@%s", f.host)
	}
	if f.port > 0 {
		uri += fmt.Sprintf(":%d", f.port)
	}
	if len(uri) > 0 {
		switch strings.TrimSpace(f.spec) {
		case "\"":
			result.WriteString(fmt.Sprintf(" \"%s\"", uri))
		case "'":
			result.WriteString(fmt.Sprintf(" '%s'", uri))
		case "<":
			result.WriteString(fmt.Sprintf(" <%s>", uri))
		default:
			result.WriteString(fmt.Sprintf(" %s", uri))
		}

	}
	if len(strings.TrimSpace(f.tag)) > 0 {
		result.WriteString(fmt.Sprintf(";tag=%s", f.tag))
	}
	if f.isOrder {
		f.isOrder = false
		for orders := range f.order {
			ordersSlice := strings.Split(orders, "=")
			if len(ordersSlice) == 1 {
				if val, ok := f.parameter.LoadAndDelete(ordersSlice[0]); ok {
					if len(strings.TrimSpace(fmt.Sprintf("%v", val))) > 0 {
						if strings.Contains(fmt.Sprintf("%v", val), "/") {
							result.WriteString(fmt.Sprintf(";%v=\"%v\"", ordersSlice[0], val))
						} else {
							result.WriteString(fmt.Sprintf(";%v=%v", ordersSlice[0], val))
						}
					} else {
						result.WriteString(fmt.Sprintf(";%v", ordersSlice[0]))
					}

				} else {
					result.WriteString(fmt.Sprintf(";%v", ordersSlice[0]))
				}
			} else {
				if val, ok := f.parameter.LoadAndDelete(ordersSlice[0]); ok {
					if len(strings.TrimSpace(fmt.Sprintf("%v", val))) > 0 {
						if strings.Contains(fmt.Sprintf("%v", val), "/") {
							result.WriteString(fmt.Sprintf(";%v=\"%v\"", ordersSlice[0], val))
						} else {
							result.WriteString(fmt.Sprintf(";%v=%v", ordersSlice[0], val))
						}
					} else {
						result.WriteString(fmt.Sprintf(";%v", ordersSlice[0]))
					}

				} else {
					if len(strings.TrimSpace(fmt.Sprintf("%v", ordersSlice[1]))) > 0 {
						result.WriteString(fmt.Sprintf(";%v=%v", ordersSlice[0], ordersSlice[1]))
					} else {
						result.WriteString(fmt.Sprintf(";%v", ordersSlice[0]))
					}
				}
			}
		}
	}
	f.parameter.Range(func(key, value interface{}) bool {
		if reflect.ValueOf(value).IsValid() {
			if reflect.ValueOf(value).IsZero() {
				result.WriteString(fmt.Sprintf(";%v", key))
				return true
			}
			if strings.Contains(fmt.Sprintf("%v", value), "/") {
				result.WriteString(fmt.Sprintf(";%v=\"%v\"", key, value))
			} else {
				result.WriteString(fmt.Sprintf(";%v=%v", key, value))
			}
			return true
		}
		result.WriteString(fmt.Sprintf(";%v", key))
		return true
	})
	result.WriteString("\r\n")
	return
}

func (f *From) Parse(raw string) {
	raw = regexp.MustCompile(`\r`).ReplaceAllString(raw, "")
	raw = regexp.MustCompile(`\n`).ReplaceAllString(raw, "")
	raw = stringTrimPrefixAndTrimSuffix(raw, " ")
	if len(strings.TrimSpace(raw)) == 0 {
		return
	}
	// from field regexp
	fieldRegexp := regexp.MustCompile(`^(?i)(from|f)( )*:`)
	if !fieldRegexp.MatchString(raw) {
		return
	}
	f.field = regexp.MustCompile(`:`).ReplaceAllString(fieldRegexp.FindString(raw), "")
	f.source = raw
	f.parameter = sync.Map{}
	raw = fieldRegexp.ReplaceAllString(raw, "")
	raw = stringTrimPrefixAndTrimSuffix(raw, " ")

	// schema regexp
	schemasRegexpStr := `(?i)(`
	for _, v := range schemas {
		schemasRegexpStr += v + "|"
	}
	schemasRegexpStr = strings.TrimSuffix(schemasRegexpStr, "|")
	schemasRegexpStr += ")( )?:"

	// display-name regexp
	nameRegexp := regexp.MustCompile(`.*` + schemasRegexpStr)
	if nameRegexp.MatchString(raw) {
		name := nameRegexp.FindString(raw)
		name = regexp.MustCompile(schemasRegexpStr+`$`).ReplaceAllString(name, "")
		name = regexp.MustCompile(`<$`).ReplaceAllString(name, "")
		name = stringTrimPrefixAndTrimSuffix(name, " ")
		if len(name) > 0 {
			f.name = name
			raw = regexp.MustCompile(`.*`+name).ReplaceAllString(raw, "")
			raw = stringTrimPrefixAndTrimSuffix(raw, " ")
		}
	}
	//uri spec  regexp: named spec of URI
	switch {
	case regexp.MustCompile(`'.*?` + schemasRegexpStr).MatchString(raw):
		f.spec = "'"
		raw = regexp.MustCompile(`.*'`).ReplaceAllString(raw, "")
	case regexp.MustCompile(`".*?` + schemasRegexpStr).MatchString(raw):
		f.spec = "\""
		raw = regexp.MustCompile(`.*"`).ReplaceAllString(raw, "")
	case regexp.MustCompile(`<.*?` + schemasRegexpStr).MatchString(raw):
		f.spec = "<"
		raw = regexp.MustCompile(`.*<`).ReplaceAllString(raw, "")
	default:
		f.spec = ""
	}
	raw = stringTrimPrefixAndTrimSuffix(raw, " ")
	// schema regexp
	schemaRegexp := regexp.MustCompile(schemasRegexpStr)
	if schemaRegexp.MatchString(raw) {
		schema := schemaRegexp.FindString(raw)
		schema = regexp.MustCompile(`:`).ReplaceAllString(schema, "")
		schema = stringTrimPrefixAndTrimSuffix(schema, " ")
		f.schema = schema
	}

	// user regexp
	userRegexp := regexp.MustCompile(schemasRegexpStr + `.*@`)
	if userRegexp.MatchString(raw) {
		user := userRegexp.FindString(raw)
		user = regexp.MustCompile(schemasRegexpStr).ReplaceAllString(user, "")
		user = regexp.MustCompile(`@`).ReplaceAllString(user, "")
		user = stringTrimPrefixAndTrimSuffix(user, " ")
		if len(user) > 0 {
			f.user = user
			raw = regexp.MustCompile(`.*`+user).ReplaceAllString(raw, "")
		}

	}
	raw = stringTrimPrefixAndTrimSuffix(raw, " ")
	// host regexp
	hostRegexp := regexp.MustCompile(`@.*`)
	if hostRegexp.MatchString(raw) {
		host := hostRegexp.FindString(raw)
		host = regexp.MustCompile(`;.*`).ReplaceAllString(host, "")
		host = regexp.MustCompile(`:.*`).ReplaceAllString(host, "")
		host = regexp.MustCompile(`@`).ReplaceAllString(host, "")
		host = stringTrimPrefixAndTrimSuffix(host, " ")
		if len(host) > 0 {
			f.host = host
			raw = regexp.MustCompile(`.*`+host).ReplaceAllString(raw, "")
		}
	}
	raw = stringTrimPrefixAndTrimSuffix(raw, " ")
	// port regexp
	portRegexp := regexp.MustCompile(`.*?:\d+`)
	if portRegexp.MatchString(raw) {
		ports := portRegexp.FindString(raw)
		ports = regexp.MustCompile(`.*:`).ReplaceAllString(ports, "")
		ports = stringTrimPrefixAndTrimSuffix(ports, " ")
		if len(ports) > 0 {
			port, _ := strconv.Atoi(ports)
			f.port = uint16(port)
			raw = regexp.MustCompile(`.*`+ports).ReplaceAllString(raw, "")
		}
	}
	raw = stringTrimPrefixAndTrimSuffix(raw, " ")
	// tag regexp
	tagRegexp := regexp.MustCompile(`(?i)(tag)( )?=.*`)
	if tagRegexp.MatchString(raw) {
		tag := tagRegexp.FindString(raw)
		tag = regexp.MustCompile(`(?i)tag( )?=`).ReplaceAllString(tag, "")
		tag = regexp.MustCompile(`;.*`).ReplaceAllString(tag, "")
		tag = stringTrimPrefixAndTrimSuffix(tag, " ")
		if len(tag) > 0 {
			f.tag = tag
			raw = regexp.MustCompile(`.*`+tag).ReplaceAllString(raw, "")
		}
	}
	raw = stringTrimPrefixAndTrimSuffix(raw, " ")
	raw = stringTrimPrefixAndTrimSuffix(raw, ";")
	raw = stringTrimPrefixAndTrimSuffix(raw, " ")
	f.parameterOrder(raw)
	// parameter regexp
	if len(raw) > 0 {
		rawSlice := strings.Split(raw, ";")
		if len(rawSlice) == 1 {
			kvs := strings.Split(rawSlice[0], "=")
			if len(kvs) == 1 {
				f.parameter.Store(kvs[0], "")
			} else {
				f.parameter.Store(kvs[0], kvs[1])
			}
		} else {
			for _, raws := range rawSlice {
				kvs := strings.Split(raws, "=")
				if len(kvs) == 1 {
					f.parameter.Store(kvs[0], "")
				} else {
					f.parameter.Store(kvs[0], kvs[1])
				}
			}
		}
	}
}
func (f *From) parameterOrder(raw string) {
	f.isOrder = true
	f.order = make(chan string, 1024)
	defer close(f.order)
	raw = stringTrimPrefixAndTrimSuffix(raw, ";")
	raw = stringTrimPrefixAndTrimSuffix(raw, " ")
	rawSlice := strings.Split(raw, ";")
	for _, raws := range rawSlice {
		f.order <- raws
	}
}
